<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>WebGPU Compute Shader - Particles</title>
		<style>
			body { margin: 0; background-color: #111; color: white; font-family: sans-serif; text-align: center;}
			canvas { background-color: #000; display: block; width: 100vw; height: 100vh; }
			#info { position: absolute; top: 10px; width: 100%; }
			#error { display: none; background-color: #ff4444; padding: 1rem; border-radius: 0.5rem; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
		</style>
	</head>
	<body>
		<div id="info">WebGPU Compute Shader: 500,000 Particles</div>
		<canvas></canvas>
		<div id="error">
			<h2>WebGPU Not Available</h2>
			<p>Your browser does not support WebGPU. Please use a recent version of Chrome, Edge, or another compatible browser.</p>
		</div>
		<script type="module">
			/**
			* EXPLANATION OF THE PARTICLE SIMULATION
			* -------------------------------------
			* This example showcases the power of WebGPU's compute shaders to simulate and render a large number
			* of particles efficiently. The key idea is to do all the heavy lifting on the GPU.
			*
			* This version uses a "ping-pong" or double-buffering technique to avoid synchronization hazards.
			* We use two particle buffers; in each frame, the compute shader reads from one and writes the
			* updated positions to the other. The render pass then reads from the buffer that was just written to.
			*
			* 1. COMPUTE STAGE:
			* - A compute shader (`compute_main`) is dispatched.
			* - It reads particle data from an input buffer (`particlesIn`).
			* - It calculates the new position and writes it to an output buffer (`particlesOut`).
			*
			* 2. RENDER STAGE:
			* - A standard render pipeline is dispatched.
			* - Its vertex buffer is set to the buffer that was the *output* of the compute stage.
			*
			* By swapping which buffer is the input and which is the output each frame, we ensure the render
			* stage always has a complete, stable set of data to draw from.
			*/
			async function main() {
				if (!navigator.gpu) {
					document.getElementById('error').style.display = 'block';
					throw new Error("WebGPU not supported");
				}
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) throw new Error("No adapter found");
				const device = await adapter.requestDevice();
				const canvas = document.querySelector("canvas");
				const context = canvas.getContext("webgpu");
				const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
				const observer = new ResizeObserver(entries => {
					for (const entry of entries) {
						const { width, height } = entry.contentRect;
						canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
						canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
					}
					});
					observer.observe(canvas);
					context.configure({ device, format: canvasFormat, alphaMode: 'premultiplied' });
					const NUM_PARTICLES = 500000;
					const particleData = new Float32Array(NUM_PARTICLES * 4);
					for (let i = 0; i < NUM_PARTICLES; i++) {
						const idx = i * 4;
						particleData[idx] = Math.random() * 2 - 1; // position x
						particleData[idx + 1] = Math.random() * 2 - 1; // position y
						particleData[idx + 2] = (Math.random() - 0.5) * 0.01; // velocity x
						particleData[idx + 3] = (Math.random() - 0.5) * 0.01; // velocity y
					}
					
					const particleBuffers = new Array(2);
					for (let i = 0; i < 2; i++) {
						particleBuffers[i] = device.createBuffer({
							size: particleData.byteLength,
							usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
							});
						}
						device.queue.writeBuffer(particleBuffers[0], 0, particleData);
						
						const uniforms = new Float32Array([canvas.width, canvas.height]);
						const uniformBuffer = device.createBuffer({
							size: uniforms.byteLength,
							usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
							});
							device.queue.writeBuffer(uniformBuffer, 0, uniforms);
							
							const wgslShaders = `
							struct Particle { pos: vec2<f32>, vel: vec2<f32> };
							struct Uniforms { screen_dim: vec2<f32> };
							
							@group(0) @binding(0) var<storage, read> particlesIn: array<Particle>;
							@group(0) @binding(1) var<storage, read_write> particlesOut: array<Particle>;
							
							@group(1) @binding(0) var<uniform> uniforms: Uniforms;
							
							@compute @workgroup_size(64)
							fn compute_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
								let index = global_id.x;
								var p = particlesIn[index];
								p.pos += p.vel;
								if (p.pos.x > 1.0) { p.pos.x = -1.0; } else if (p.pos.x < -1.0) { p.pos.x = 1.0; }
								if (p.pos.y > 1.0) { p.pos.y = -1.0; } else if (p.pos.y < -1.0) { p.pos.y = 1.0; }
								particlesOut[index] = p;
							}
							@vertex fn vs_main(@location(0) in_pos: vec2<f32>) -> @builtin(position) vec4<f32> {
								let ratio = uniforms.screen_dim.x / uniforms.screen_dim.y;
								return vec4<f32>(in_pos.x / ratio, in_pos.y, 0.0, 1.0);
							}
							@fragment fn fs_main() -> @location(0) vec4<f32> { return vec4<f32>(0.1, 0.4, 1.0, 0.5); }
							`;
							const shaderModule = device.createShaderModule({ code: wgslShaders });
							
							// --- SEPARATE LAYOUTS AND BIND GROUPS ---
							const computeBindGroupLayout = device.createBindGroupLayout({
								entries: [
								{ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
								{ binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
								]
								});
								
								const renderBindGroupLayout = device.createBindGroupLayout({
									entries: [
									{ binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } }
									]
									});
									
									const computePipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [computeBindGroupLayout] });
									const renderPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [ , renderBindGroupLayout] }); // The comma creates an empty slot at index 0
									
									const computeBindGroups = new Array(2);
									for (let i = 0; i < 2; i++) {
										computeBindGroups[i] = device.createBindGroup({
											layout: computeBindGroupLayout,
											entries: [
											{ binding: 0, resource: { buffer: particleBuffers[i] } },
											{ binding: 1, resource: { buffer: particleBuffers[(i + 1) % 2] } },
											],
											});
										}
										
										const renderBindGroup = device.createBindGroup({
											layout: renderBindGroupLayout,
											entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
											});
											
											const computePipeline = device.createComputePipeline({
												layout: computePipelineLayout,
												compute: { module: shaderModule, entryPoint: 'compute_main' },
												});
												
												const renderPipeline = device.createRenderPipeline({
													layout: renderPipelineLayout,
													vertex: {
														module: shaderModule,
														entryPoint: 'vs_main',
														buffers: [{ arrayStride: 4 * 4, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }],
														},
														fragment: {
															module: shaderModule, entryPoint: 'fs_main',
															targets: [{ format: canvasFormat, blend: { color: { operation: 'add', srcFactor: 'one', dstFactor: 'one' }, alpha: { operation: 'add', srcFactor: 'one', dstFactor: 'one' } } }],
															},
															primitive: { topology: 'point-list' },
															});
															
															let frameCount = 0;
															function frame() {
																device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([canvas.width, canvas.height]));
																const commandEncoder = device.createCommandEncoder();
																
																const computePass = commandEncoder.beginComputePass();
																computePass.setPipeline(computePipeline);
																computePass.setBindGroup(0, computeBindGroups[frameCount % 2]);
																computePass.dispatchWorkgroups(Math.ceil(NUM_PARTICLES / 64));
																computePass.end();
																
																const textureView = context.getCurrentTexture().createView();
																const renderPass = commandEncoder.beginRenderPass({
																	colorAttachments: [{ view: textureView, loadOp: 'clear', clearValue: { r: 0, g: 0, b: 0, a: 1 }, storeOp: 'store' }],
																	});
																	renderPass.setPipeline(renderPipeline);
																	renderPass.setBindGroup(1, renderBindGroup); // Set the bind group at index 1 to match the shader
																	renderPass.setVertexBuffer(0, particleBuffers[(frameCount + 1) % 2]); // Use the output buffer from the compute pass
																	renderPass.draw(NUM_PARTICLES);
																	renderPass.end();
																	
																	device.queue.submit([commandEncoder.finish()]);
																	
																	frameCount++;
																	requestAnimationFrame(frame);
																}
																requestAnimationFrame(frame);
															}
															main().catch(err => console.error(err));
		</script>
	</body>
</html>
