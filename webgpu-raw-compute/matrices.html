<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>WebGPU Machine Learning - MatMul</title>
		<style>
			body { font-family: sans-serif; background-color: #111; color: #eee; margin: 2rem; }
			pre { background-color: #222; padding: 1rem; border-radius: 0.5rem; white-space: pre-wrap; word-wrap: break-word; }
			h1, h2 { color: #4af; }
			#error { display: none; background-color: #ff4444; padding: 1rem; border-radius: 0.5rem; }
		</style>
	</head>
	<body>
		<h1>WebGPU for Machine Learning</h1>
		<h2>Matrix Multiplication (MatMul) Example</h2>
		<p>This example computes the product of two matrices entirely on the GPU using a compute shader.</p>

		<h2>Input Matrix A (2x3)</h2>
		<pre id="matrixA"></pre>

		<h2>Input Matrix B (3x2)</h2>
		<pre id="matrixB"></pre>

		<h2>Result Matrix C (2x2) - Computed by GPU</h2>
		<pre id="matrixC">Computing...</pre>

		<div id="error">
			<h2>WebGPU Not Available</h2>
			<p>Your browser does not support WebGPU. Please use a recent version of Chrome, Edge, or another compatible browser.</p>
		</div>

		<script type="module">
			async function main() {
				// 1. Setup
				if (!navigator.gpu) {
					document.getElementById('error').style.display = 'block';
					throw new Error("WebGPU not supported");
				}
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) throw new Error("No adapter found");
				const device = await adapter.requestDevice();
				
				// 2. Data and Buffers
				const matrixA = new Float32Array([ 1, 2, 3, 4, 5, 6 ]);
				const dimsA = new Int32Array([2, 3]);
				const matrixB = new Float32Array([ 7, 8, 9, 10, 11, 12 ]);
				const dimsB = new Int32Array([3, 2]);
				
				const bufferA = device.createBuffer({
					size: matrixA.byteLength,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: true,
					});
					new Float32Array(bufferA.getMappedRange()).set(matrixA);
					bufferA.unmap();
					
					const bufferB = device.createBuffer({
						size: matrixB.byteLength,
						usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
						mappedAtCreation: true,
						});
						new Float32Array(bufferB.getMappedRange()).set(matrixB);
						bufferB.unmap();
						
						const resultMatrixBufferSize = dimsA[0] * dimsB[1] * Float32Array.BYTES_PER_ELEMENT;
						const resultBuffer = device.createBuffer({
							size: resultMatrixBufferSize,
							usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
							});
							
							const dimsBuffer = device.createBuffer({
								size: (2 + 2) * Int32Array.BYTES_PER_ELEMENT,
								usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
								mappedAtCreation: true,
								});
								new Int32Array(dimsBuffer.getMappedRange()).set([...dimsA, ...dimsB]);
								dimsBuffer.unmap();
								
								// 3. WGSL Compute Shader
								const wgslCode = `
								struct Matrix { data: array<f32>, };
								@group(0) @binding(0) var<storage, read> matrixA: Matrix;
								@group(0) @binding(1) var<storage, read> matrixB: Matrix;
								@group(0) @binding(2) var<storage, read_write> matrixC: Matrix;
								struct Dims { m: i32, k: i32, k_b: i32, n: i32, };
								@group(0) @binding(3) var<uniform> dims: Dims;
								
								@compute @workgroup_size(8, 8)
								fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
									let row = global_id.x;
									let col = global_id.y;
									if (row >= u32(dims.m) || col >= u32(dims.n)) { return; }
									var sum = 0.0;
									for (var i = 0u; i < u32(dims.k); i = i + 1u) {
										let a_index = row * u32(dims.k) + i;
										let b_index = i * u32(dims.n) + col;
										sum = sum + matrixA.data[a_index] * matrixB.data[b_index];
									}
									matrixC.data[row * u32(dims.n) + col] = sum;
								}
								`;
								const shaderModule = device.createShaderModule({ code: wgslCode });
								
								// 4. Pipeline and Bind Group
								const computePipeline = device.createComputePipeline({
									layout: 'auto',
									compute: { module: shaderModule, entryPoint: 'main' },
									});
									
									const bindGroup = device.createBindGroup({
										layout: computePipeline.getBindGroupLayout(0),
										entries: [
										{ binding: 0, resource: { buffer: bufferA } },
										{ binding: 1, resource: { buffer: bufferB } },
										{ binding: 2, resource: { buffer: resultBuffer } },
										{ binding: 3, resource: { buffer: dimsBuffer } },
										],
										});
										
										// 5. Command Execution
										const commandEncoder = device.createCommandEncoder();
										const passEncoder = commandEncoder.beginComputePass();
										passEncoder.setPipeline(computePipeline);
										passEncoder.setBindGroup(0, bindGroup);
										const workgroupCountX = Math.ceil(dimsA[0] / 8);
										const workgroupCountY = Math.ceil(dimsB[1] / 8);
										passEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY);
										passEncoder.end();
										
										// 6. Readback result
										const readbackBuffer = device.createBuffer({
											size: resultMatrixBufferSize,
											usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
											});
											commandEncoder.copyBufferToBuffer(resultBuffer, 0, readbackBuffer, 0, resultMatrixBufferSize);
											device.queue.submit([commandEncoder.finish()]);
											await readbackBuffer.mapAsync(GPUMapMode.READ);
											const result = new Float32Array(readbackBuffer.getMappedRange());
											
											// 7. Display Results
											document.getElementById('matrixA').textContent = `[${matrixA.slice(0, 3).join(', ')}]\n[${matrixA.slice(3, 6).join(', ')}]`;
											document.getElementById('matrixB').textContent = `[${matrixB[0]}, ${matrixB[1]}]\n[${matrixB[2]}, ${matrixB[3]}]\n[${matrixB[4]}, ${matrixB[5]}]`;
											document.getElementById('matrixC').textContent = `[${result[0]}, ${result[1]}]\n[${result[2]}, ${result[3]}]`;
											
											readbackBuffer.unmap();
										}
										
										main().catch(err => {
											console.error(err);
											document.getElementById('error').style.display = 'block';
											});
		</script>
	</body>
</html>
